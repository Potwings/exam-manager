===== PROBLEMS =====
--- Q1 ---
OOP(객체 지향 프로그래밍)의 4대 특징을 설명하세요.

--- Q2 ---
Overloading과 Overriding의 차이점을 설명하세요.

--- Q3 ---
JAVA 접근제어자의 종류와 각각의 제한 범위에 대하여 설명하세요.

--- Q4 ---
자료형의 기본타입(primitive type)과 래퍼 클래스(wrapper class)에 대해 설명하세요.

--- Q5 ---
Process와 Thread에 대해 설명하세요.

--- Q6 ---
GET, POST에 대해 설명하세요.

--- Q7 ---
Cookie와 Session에 대해 설명하세요.

--- Q8 ---
가비지 컬렉션(Garbage Collection)에 대해 설명하세요.

--- Q9 ---
아래의 코드의 실행 결과를 작성하세요.
public static void main (String[] argv) {
String number;
System.out.println(toInt(number));
number = "9900";
System.out.println(toInt(number));
number = "10";
System.out.println(toInt(number));
}
public static int toInt l(String strValue) {
if ( strValue == null || strValue.length() == 0 ) {
throw new IllegalArgumentException();
}
int intValue = 0;
try {
intValue = Integer.parseInt(strValue);
} catch (Exception e) {
intValue = 0;
}
return intValue;
}

--- Q10 ---
아래의 코드의 실행 결과를 작성하세요.
public static void main(String[] args) {
String s1 = new String("abc");
String s2 = new String("xyz");
if (s1 == s2) {
System.out.println("s1 == s2 is true");
} else {
System.out.println("s1 == s2 is false");
}
String s3 = s1;
if (s1 == s3) {
System.out.println("s1 == s3 is true");
} else {
System.out.println("s1 == s3 is false");
}
if (s1.equals(s3)) {
System.out.println("s1 == s3 is true");
} else {
System.out.println("s1 == s3 is false");
}
s1 = new String("abc");
s2 = new String("abc");
if (s1 == s2) {
System.out.println("s1 == s2 is true");
} else {
System.out.println("s1 == s2 is false");
}
}

--- Q11 ---
아래의 javascript코드의 실행 결과를 작성하세요.
var x = 10;
console.log(x);
function test () {
var x = 20;
console.log(x);
if (x > 10) {
let x = 30;
console.log(x);
}
console.log(x);
}
test();
console.log(x);

--- Q12 ---
아래의 코드의 실행 결과는 undefined입니다. 이유를 설명하세요.
async function foo(){
return 'test';
}
var result = foo();
console.log(result);

--- Q13 ---
아래 조직 정보 테이블이 있습니다. 각 하위 질문에 맞는 답변을 작성하세요.
[표]
사원정보 |  | 직급정보 |  | 부서정보
사원번호 | 이름 | 직급코드 | 부서코드 |  | 직급코드 | 직급명 | 정렬 |  | 부서코드 | 부서명
1 | 홍이사 | 6 | 1 |  | 1 | 사원 | 7 |  | 1 | 개발팀
2 | 최사원 | 1 | 1 |  | 2 | 대리 | 6 |  | 2 | 영업팀
3 | 나사장 | 7 | 0 |  | 3 | 과장 | 5 |  |  | 
4 | 김차장 | 4 | 1 |  | 4 | 차장 | 4 |  |  | 
5 | 박대리 | 2 | 1 |  | 5 | 부장 | 3 |  |  | 
6 | 오부장 | 5 | 2 |  | 6 | 이사 | 2 |  |  | 
7 | 조사원 | 1 | 1 |  | 7 | 사장 | 1 |  |  | 
8 | 고이사 | 6 | 2 |  |  |  |  |  |  | 
9 | 이과장 | 3 | 2 |  |  |  |  |  |  | 

사원정보를 추가하는 쿼리를 작성하세요. 단 사원번호는 자동 증가합니다.
[표]
이름 : 정사원, 부서명 : 개발팀, 직급명 : 사원

사원정보를 수정하는 쿼리를 작성하세요.
[표]
최사원이 영업팀으로 이동

사원 정보를 삭제하는 쿼리를 작성하세요
[표]
사원번호가 9인 사원이 퇴사

사용정보를 출력하는 쿼리를 작성하세요
[표]
직급명이 사원인 사용자들의 이름과 부서명 출력

[표]
사원정보 |  | 직급정보 |  | 부서정보
사원번호 | 이름 | 직급코드 | 부서코드 |  | 직급코드 | 직급명 | 정렬 |  | 부서코드 | 부서명
1 | 홍이사 | 6 | 1 |  | 1 | 사원 | 7 |  | 1 | 개발팀
2 | 최사원 | 1 | 1 |  | 2 | 대리 | 6 |  | 2 | 영업팀
3 | 나사장 | 7 | 0 |  | 3 | 과장 | 5 |  |  | 
4 | 김차장 | 4 | 1 |  | 4 | 차장 | 4 |  |  | 
5 | 박대리 | 2 | 1 |  | 5 | 부장 | 3 |  |  | 
6 | 오부장 | 5 | 2 |  | 6 | 이사 | 2 |  |  | 
7 | 조사원 | 1 | 1 |  | 7 | 사장 | 1 |  |  | 
8 | 고이사 | 6 | 2 |  |  |  |  |  |  | 
9 | 이과장 | 3 | 2 |  |  |  |  |  |  | 

제약사항을 준수하여 아래의 결과를 출력할 수 있는 쿼리를 작성하세요.
[표]
결과 |  | 제약사항1. 사원은 출력하지 않음2. 사원정보의 부서코드가 부서정보에 존재하지 않는 경우 빈 칸으로 출력함3. 결과는 직급정보의 정렬 순서와 이름으로 오름차순 정렬함
사원번호 | 이름 | 부서명 | 직급명 |  | 
3 | 나사장 |  | 사장 |  | 
8 | 고이사 | 영업팀 | 이사 |  | 
1 | 홍이사 | 개발팀 | 이사 |  | 
6 | 오부장 | 영업팀 | 부장 |  | 
4 | 김차장 | 개발팀 | 차장 |  | 
9 | 이과장 | 영업팀 | 과장 |  | 
5 | 박대리 | 개발팀 | 대리 |  |

--- Q14 ---
아래의 조건대로 함수를 작성하세요.
[표]
1. 문자열의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수를 완성하세요.2. 입출력 예    - input : hello java world → output : HeLlO JaVa wOrLd

===== ANSWERS =====
--- A1 (score: 8) ---
추상화, 캡슐화, 상속성, 다형성에 대해 설명 (각 2점)

--- A2 (score: 6) ---
Overloading : 같은 이름의 메서드를 여러 개 정의
매개변수의 타입이나 개수가 달라야 함 (3점)
Overriding : 부모 클래스의 메서드를 자식 클래스에서 상속받아서 재정의
매개변수의 타입이나 개수가 같아야 함 (3점)-

--- A3 (score: 6) ---
Private : 같은 클래스 내에서만 접근 가능 (2점)
Public : 접근 제한이 없음. (같은 프로젝트 내에서) (2점)
Protected : 같은 패키지 내에서 (2점)

--- A4 (score: 6) ---
기본 타입 : 메모리에 저장되어 있는 값(value)을 복사하여 보낸다. (int, boolean, …) (3점)
래퍼 클래스: 객체로 기본타입을 감싼 것, 객체로 데이터 다룰 때 사용(Integer, Boolean …)(3점)

--- A5 (score: 6) ---
Process : 메모리에 올라와 실행되고 있는 프로그램의 인스턴스, 실행 중인 프로그램, 운영체제로부터 시스템 자원을 할당받는 작업의 단위 (3점)
Thread : 프로세스 내에서 실제로 작업을 수행하는 주체, 프로세스가 할당받은 자원을 이용하는 실행의 단위 (3점)

--- A6 (score: 6) ---
GET : URL, Header에 데이터가 포함, 길이 제한, 보안에 취약 (3점)
POST : 데이터가 Body에 포함, URL에 데이터가 노출되지 않음 (3점)

--- A7 (score: 6) ---
Cookie : 클라이언트 로컬에 저장되는 키와 값이 들어있는 데이터 파일 (3점)
Session : 웹 브라우저를 통해 웹 서버에 접속한 이후로 브라우저를 종료할 때까지 유지되는 상태, 서버에 저장 (3점)

--- A8 (score: 6) ---
메모리관리, 객체 해제, 메모리 누수 방지

--- A9 (score: 5) ---
public static void main(String[] argv) {
String number;
System.out.println(toInt(number));
number = "9900";
System.out.println(toInt(number));
number = "10";
System.out.println(toInt(number));
}
public static int toInt(String strValue) {
If ( strValue == null || strValue.length() == 0 ) {
throw new IllegalArgumentException();
}
int intValue = 0;
try {
intValue = Integer.parseInt(strValue);
} catch (Exception e) {
intValue = 0;
}
return intValue;
}
오류가 발생한다. (2점)
number가 초기화되지 않은 상태로 매개변수로 사용할 수 없음. (3점)

--- A10 (score: 5) ---
public static void main(String[] args) {
String s1 = new String("abc");
String s2 = new String("xyz");
if (s1 == s2) {
System.out.println("s1 == s2 is true");
} else {
System.out.println("s1 == s2 is false");
}
String s3 = s1;
if (s1 == s3) {
System.out.println("s1 == s3 is true");
} else {
System.out.println("s1 == s3 is false");
}
if (s1.equals(s3)) {
System.out.println("s1 == s3 is true");
} else {
System.out.println("s1 == s3 is false");
}
s1 = new String("abc");
s2 = new String("abc");
if (s1 == s2) {
System.out.println("s1 == s2 is true");
} else {
System.out.println("s1 == s2 is false");
}
}
s1 == s2 is false (1점)
s1 == s3 is true (1점)
s1 == s3 is true (1점)
s1 == s2 is false (2점)

--- A11 (score: 5) ---
var x = 10;
console.log(x);
function test () {
var x = 20;
console.log(x);
if (x > 10) {
let x = 30;
console.log(x);
}
console.log(x);
}
test();
console.log(x);
10
20
30
20
10
출력 결과를 전부 맞춰야 (5점)

--- A12 (score: 3) ---
async function foo(){
return 'test';
}
var result = foo();
console.log(result);
비동기를 언급하면 (3점)

--- A13 (score: 22) ---
[표]
사원정보 |  | 직급정보 |  | 부서정보
사원번호 | 이름 | 직급코드 | 부서코드 |  | 직급코드 | 직급명 | 정렬 |  | 부서코드 | 부서명
1 | 홍이사 | 6 | 1 |  | 1 | 사원 | 7 |  | 1 | 개발팀
2 | 최사원 | 1 | 1 |  | 2 | 대리 | 6 |  | 2 | 영업팀
3 | 나사장 | 7 | 0 |  | 3 | 과장 | 5 |  |  | 
4 | 김차장 | 4 | 1 |  | 4 | 차장 | 4 |  |  | 
5 | 박대리 | 2 | 1 |  | 5 | 부장 | 3 |  |  | 
6 | 오부장 | 5 | 2 |  | 6 | 이사 | 2 |  |  | 
7 | 조사원 | 1 | 1 |  | 7 | 사장 | 1 |  |  | 
8 | 고이사 | 6 | 2 |  |  |  |  |  |  | 
9 | 이과장 | 3 | 2 |  |  |  |  |  |  | 

A. 신규 입사자를 추가하는 쿼리를 작성하세요. 단, 사원번호는 자동 증가합니다. (3점)
[표]
이름 : 정사원, 부서 : 개발팀, 직급 : 사원

INSERT INTO 사원정보(이름, 직급코드, 부서코드) VALUES (’정사원’, 1, 1);
INSERT INTO 사원정보(사원번호, 이름, 직급코드, 부서코드) VALUES (사원번호.seq.NEXTVAL, ’정사원’, 1, 1);
B. 사원 정보 수정 쿼리 (2점)
[표]
최사원이 영업팀으로 이동

UPDATE 사원정보 SET 부서코드 =2 WHERE 사원번호=2;
UPDATE 사원정보 SET 부서명 =’영업팀’ WHERE 사원번호=2;
UPDATE 사원정보 SET 부서명 =’영업팀’ WHERE 이름=’최사원’;
C. 사원 정보 삭제 쿼리 (2점)
[표]
사원번호가 9인 사원이 퇴사

DELETE FROM 사원정보 WHERE 사원번호=9;
D. 사원 정보 출력 쿼리 (5점)
[표]
직급명이 사원인 사용자들의 이름과 부서명 출력

SELECT a.이름, b.부서명
FROM 사원정보 a
JOIN 부서정보b ON a.부서코드 = b.부서코드
JOIN 직급정보 c ON a.직급코드 = c.직급코드
WHERE c.직급명 = ‘사원’;
E. 제약사항을 준수하여 아래의 결과를 출력할 수 있는 쿼리를 작성하세요. (10점)
[표]
결과 |  | 제약사항1. 사원은 출력하지 않음2. 사원정보의 부서코드가 부서정보에 존재하지 않는 경우 빈 칸으로 출력함3. 결과는 직급정보의 정렬 순서와 이름으로 오름차순 정렬함
사원번호 | 이름 | 부서명 | 직급명 |  | 
3 | 나사장 |  | 사장 |  | 
8 | 고이사 | 영업팀 | 이사 |  | 
1 | 홍이사 | 개발팀 | 이사 |  | 
6 | 오부장 | 영업팀 | 부장 |  | 
4 | 김차장 | 개발팀 | 차장 |  | 
9 | 이과장 | 영업팀 | 과장 |  | 
5 | 박대리 | 개발팀 | 대리 |  | 

SELECT s.사원번호, s.이름, b.부서명, j.직급명
FROM 사원정보 s
INNER JOIN 직급정보 j ON s.직급코드 = j.직급코드
LEFT OUTER JOIN 부서정보 b ON s.부서코드 = b.부서코드
WHERE s.직급코드 > 1
ORDER BY j.정렬 ASC, s.이름 ASC;
SELECT s.사원번호, s.이름, b.부서명, j.직급명
FROM 사원정보 s
RIGHT OUTER JOIN 직급정보 j ON s.직급코드 = j.직급코드
LEFT OUTER JOIN 부서정보 b ON s.부서코드 = b.부서코드
WHERE s.직급코드 > 1
ORDER BY j.정렬 ASC, s.이름 ASC;
쿼리 결과가 맞으면 (10점)
* 현재 제약 사항 일 경우
- 최사원, 조사원 사원정보 직급 코드를 직급 정보에 없는 정보로 변경 필요
- 쿼리
SELECT s.사원번호, s.이름, b.부서명, j.직급명
FROM 사원정보 s
RIGHT OUTER JOIN 직급정보 j ON s.직급코드 = j.직급코드
LEFT OUTER JOIN 부서정보 b ON s.부서코드 = b.부서코드
ORDER BY j.정렬 ASC, s.이름 ASC;
혹은
SELECT s.사원번호, s.이름, b.부서명, j.직급명
FROM 사원정보 s
INNER JOIN 직급정보 j ON s.직급코드 = j.직급코드
LEFT OUTER JOIN 부서정보 b ON s.부서코드 = b.부서코드
ORDER BY j.정렬 ASC, s.이름 ASC;
* 위의 데이터 유지 시
- 2번제약 사항 불필요
- 직급정보가 사원이 아닌 사원 정보 제약 조건 추가
- 쿼리
SELECT s.사원번호, s.이름, b.부서명, j.직급명
FROM 사원정보 s
LEFT OUTER JOIN 직급정보 j ON s.직급코드 = j.직급코드
LEFT OUTER JOIN 부서정보 b ON s.부서코드 = b.부서코드
WHERE s.직급코드 > 1
ORDER BY j.정렬 ASC, s.이름 ASC;

--- A14 (score: 10) ---
[표]
1. 문자열의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수를 완성하세요.2. 입출력 예    - input : hello java world → output : HeLlO JaVa wOrLd

public static void main(String[] args) {
String inputStr = "hello java world";
StringBuilder sb = new StringBuilder();
String[] sArr = inputStr.split("");
for (int i = 0; i < sArr.length; i++) {
if (i % 2 == 0) {
sb.append(sArr[i].toUpperCase()); // 짝수
} else {
sb.append(sArr[i].toLowerCase()); // 홀수
}
}
System.out.println(sb.toString());
}
Char 사용시
public static void main(String[] args) {
String inputStr = "hello java world";
String b = "";
for (int i = 0; i < inputStr.length(); i++) {
char s = inputStr.charAt(i);
if (String.valueOf(s).equals(" ")) {
b += String.valueOf(s);
} else if (i % 2 == 0) {
b += String.valueOf(s).toUpperCase(); // 짝수
} else {
b += String.valueOf(s).toLowerCase(); // 홀수
}
}
System.out.println(b);
}
결과가 맞으면 (10점)

